The code is mainly modern Fortran, with a few parts still clearly showing their Fortran 77 heritage. Fortran 2003 features are used heavily (especially allocatable array features). The code needs to be processed with {\ttfamily cpp} or a compatible pre-\/processor.\hypertarget{coding_style_oo_fortran}{}\section{Object Oriented Fortran}\label{coding_style_oo_fortran}
Extensive use is made of Fortran 90 derived types. Derived types are named {\ttfamily my\+\_\+type\+\_\+t} and are generally defined in modules named {\ttfamily pmc\+\_\+my\+\_\+type} within files named {\ttfamily my\+\_\+type.\+F90}. Almost all subroutines and function in each {\ttfamily my\+\_\+type.\+F90} file have names of the form {\ttfamily my\+\_\+type\+\_\+$\ast$}() and take an object of type {\ttfamily my\+\_\+type\+\_\+t} (called {\ttfamily my\+\_\+type}) as the first argument on which to operate.

Module names are always the same as the name of the containing file, but prefixed with {\ttfamily pmc\+\_\+}. Thus the module {\ttfamily \mbox{\hyperlink{namespacepmc__condense}{pmc\+\_\+condense}}} is contained in the file {\ttfamily \mbox{\hyperlink{condense_8_f90}{condense.\+F90}}}.\hypertarget{coding_style_update_2017}{}\subsection{2017 Updates}\label{coding_style_update_2017}
Some changes were made beginning with the \mbox{\hyperlink{phlex_chem}{Phlexible Module for Chemistry}} to take advantage of Fortran 2003 and 2008 features. In general, modules are {\ttfamily private} and expose functionality through type-\/bound procedures. {\ttfamily public} module functions, variables and parameters are discouraged, as are {\ttfamily public} derived-\/type variables.

Constructors that return a pointer to a newly allocated instance of a module\textquotesingle{}s primary derived type are typically included in each module. In addition to the primary derived type, a pointer type may be included for building arrays of pointers to the primary derived type. For example, the {\ttfamily my\+\_\+type\+\_\+t} type may have an associated {\ttfamily my\+\_\+type\+\_\+ptr} type in the same module whose only member is a pointer to a {\ttfamily my\+\_\+type\+\_\+t} object named {\ttfamily val}. (This helps, in particular, with building arrays of mixed extending types of an abstract type.) When abstract types are used, for example {\ttfamily my\+\_\+general\+\_\+data\+\_\+t}, a factory type in a separate module, {\ttfamily my\+\_\+general\+\_\+factory\+\_\+t}, is provided to create instances of extending types by name or from input files. Extending types are located in a {\ttfamily \textbackslash{}my\+\_\+general} folder in the {\ttfamily \textbackslash{}src} directory.\hypertarget{coding_style_mem_manage}{}\section{Memory Management}\label{coding_style_mem_manage}
The memory allocation policy to is to always use {\ttfamily allocatable} arrays and to do the allocation in the lowest-\/level routine possible. Explicit {\ttfamily allocate()} and {\ttfamily deallocate()} statements are discouraged in favor of automatic memory management, where possible. 